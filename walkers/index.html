<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Walkers V1</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #fff;
    }
    canvas {
      display: block;
      background: #fff;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <script type="module">
    import { create_game, on_sync, ping } from "./dist/index.js";

    // Setup canvas
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    // Make canvas fullscreen
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);

    // Get room and nickname from user
    const room = prompt("Enter room name:");
    if (!room) {
      alert("Room name is required!");
      throw new Error("Room name required");
    }

    const nick = prompt("Enter your nickname (single character):");
    if (!nick || nick.length !== 1) {
      alert("Nickname must be exactly one character!");
      throw new Error("Nickname must be one character");
    }

    console.log("[GAME] Room:", room, "Nick:", nick);

    // Create game instance (safe to create before sync; watch/load don't require server_time)
    // smooth(past, curr): render past world but overlay own avatar from curr
    const smooth = (past, curr) => {
      if (curr[nick]) past[nick] = curr[nick];
      return past;
    };
    const game = create_game(room, smooth);

    // Track key states
    const key_states = {
      w: false,
      a: false,
      s: false,
      d: false,
    };

    // Setup game only after first time sync
    on_sync(() => {
      // Spawn player after sync (pinned at 200,200)
      const spawn_x = 200;
      const spawn_y = 200;
      console.log(`[GAME] Synced; spawning '${nick}' at (${spawn_x},${spawn_y})`);
      game.post({ $: "spawn", nick: nick, px: spawn_x, py: spawn_y });

      // Handle keyboard input after sync
      window.addEventListener("keydown", (e) => {
        const key = e.key.toLowerCase();
        if (key === "w" || key === "a" || key === "s" || key === "d") {
          if (!key_states[key]) {
            key_states[key] = true;
            game.post({ $: "down", key: key, player: nick });
          }
        }
      });

      window.addEventListener("keyup", (e) => {
        const key = e.key.toLowerCase();
        if (key === "w" || key === "a" || key === "s" || key === "d") {
          if (key_states[key]) {
            key_states[key] = false;
            game.post({ $: "up", key: key, player: nick });
          }
        }
      });

      // Start render loop after sync
      console.log("[GAME] Starting render at 24 FPS");
      setInterval(render, FRAME_TIME);
    });

    // Render loop at 24 FPS
    const FPS = 24;
    const FRAME_TIME = 1000 / FPS;

    let frame_count = 0;
    let last_perf_log = 0;
    let perf_samples = [];

    function render() {
      const render_start = performance.now();
      frame_count++;

      // Clear screen
      ctx.fillStyle = "#fff";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Get current game state
      const compute_start = performance.now();
      const present_tick = game.server_tick();
      const initial_tick = game.initial_tick();
      const ticks_to_process = initial_tick !== null ? present_tick - initial_tick : 0;
      const state = game.compute_render_state();
      const compute_time = performance.now() - compute_start;

      // Render overlay (top-left): time - tick - ping
      ctx.fillStyle = "#000";
      ctx.font = "14px monospace";
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      try {
        const server_time_value = game.server_time();
        const current_tick = present_tick;
        const current_ping_ms = ping();
        ctx.fillText(`time: ${server_time_value}`, 8, 6);
        ctx.fillText(`tick: ${current_tick}`, 8, 24);
        if (isFinite(current_ping_ms)) ctx.fillText(`ping: ${Math.round(current_ping_ms)} ms`, 8, 42);
      } catch {}

      // Render each player
      ctx.fillStyle = "#000";
      ctx.font = "24px monospace";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      for (const [char, player] of Object.entries(state)) {
        const x = Math.floor(player.px);
        const y = Math.floor(player.py);
        ctx.fillText(char, x, y);
      }

      const render_time = performance.now() - render_start;
      perf_samples.push({ compute: compute_time, render: render_time, ticks: ticks_to_process });

      // Log performance every 60 frames (every 2.5 seconds at 24 FPS)
      if (frame_count - last_perf_log >= 60) {
        const avg_compute = perf_samples.reduce((sum, s) => sum + s.compute, 0) / perf_samples.length;
        const avg_render = perf_samples.reduce((sum, s) => sum + s.render, 0) / perf_samples.length;
        const avg_ticks = perf_samples.reduce((sum, s) => sum + s.ticks, 0) / perf_samples.length;
        console.log(`[PERF] Frame ${frame_count} | Players: ${Object.keys(state).length} | Avg compute: ${avg_compute.toFixed(2)}ms | Avg render: ${avg_render.toFixed(2)}ms | Avg ticks/frame: ${avg_ticks.toFixed(1)}`);
        last_perf_log = frame_count;
        perf_samples = [];
      }
    }

    // Render loop starts after on_sync above
  </script>
</body>
</html>
